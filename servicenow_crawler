
#!/usr/bin/env python3
"""
ServiceNow Knowledge Crawler (Selenium + Word Export)
- Reads URLs from Excel
- Logs in via SSO or Basic
- Extracts title and content using:
    Title:  h1#articleTitleReadonly
    Content: div#article
- Saves each article as .docx
"""

import os
import re
import sys
import time
import logging
import configparser
from pathlib import Path

import pandas as pd
from bs4 import BeautifulSoup
from docx import Document

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
logger = logging.getLogger("sn_kb_crawler")

INVALID_CHARS = r'[\\/:*?"<>|]'

def sanitize_filename(name: str, max_len: int = 200) -> str:
    name = re.sub(INVALID_CHARS, "_", name).strip()
    return name[:max_len] or "Untitled"

def ensure_unique_path(folder: Path, base_name: str, ext: str = ".docx") -> Path:
    path = folder / f"{base_name}{ext}"
    counter = 1
    while path.exists():
        path = folder / f"{base_name} ({counter}){ext}"
        counter += 1
    return path

def load_config(cfg_path="config.ini"):
    cfg = configparser.ConfigParser()
    if not os.path.exists(cfg_path):
        logger.error("config.ini not found.")
        sys.exit(1)
    cfg.read(cfg_path)
    return cfg

def read_urls_from_excel(excel_path, sheet=None, url_col=None):
    if not os.path.exists(excel_path):
        logger.error(f"Excel file not found: {excel_path}")
        sys.exit(1)
    df = pd.read_excel(excel_path, sheet_name=sheet or 0, engine="openpyxl")
    if url_col and url_col in df.columns:
        urls = df[url_col].dropna().astype(str).tolist()
    else:
        urls = df[df.columns[0]].dropna().astype(str).tolist()
    return [u for u in urls if u.startswith("http")]

def create_driver(browser, headless):
    browser = browser.lower()
    if browser == "chrome":
        from selenium.webdriver.chrome.options import Options
        opts = Options()
        if headless:
            opts.add_argument("--headless=new")
        opts.add_argument("--window-size=1600,1000")
        return webdriver.Chrome(options=opts)
    elif browser == "edge":
        from selenium.webdriver.edge.options import Options
        opts = Options()
        if headless:
            opts.add_argument("--headless=new")
        return webdriver.Edge(options=opts)
    else:
        logger.error("Unsupported browser.")
        sys.exit(1)

def login_basic(driver, instance_url, username, password, wait_timeout):
    login_url = instance_url.rstrip("/") + "/login.do"
    driver.get(login_url)
    WebDriverWait(driver, wait_timeout).until(EC.presence_of_element_located((By.ID, "user_name")))
    driver.find_element(By.ID, "user_name").send_keys(username)
    driver.find_element(By.ID, "user_password").send_keys(password)
    driver.find_element(By.ID, "sysverb_login").click()
    WebDriverWait(driver, wait_timeout).until_not(EC.url_contains("login.do"))
    logger.info("Basic login successful.")

def ensure_logged_in_sso(driver, first_url, wait_timeout):
    driver.get(first_url)
    logger.info("Complete SSO login manually if prompted...")
    WebDriverWait(driver, wait_timeout).until(
        EC.any_of(
            EC.presence_of_element_located((By.ID, "gsft_main")),
            EC.presence_of_element_located((By.CSS_SELECTOR, "h1#articleTitleReadonly"))
        )
    )

def switch_into_frame(driver):
    try:
        driver.switch_to.frame("gsft_main")
        return True
    except:
        return False

TITLE_SELECTORS = ["h1#articleTitleReadonly", "h1"]
CONTENT_SELECTORS = ["div#article", "div.kb_article_content", "div.article-content"]

def extract_title_and_content(html):
    soup = BeautifulSoup(html, "lxml")
    title = next((soup.select_one(sel).get_text(strip=True) for sel in TITLE_SELECTORS if soup.select_one(sel)), "Untitled")
    content = next((soup.select_one(sel).get_text(separator="\n", strip=True) for sel in CONTENT_SELECTORS if soup.select_one(sel)), "No content found.")
    return title, content

def save_to_word(folder, title, content):
    folder.mkdir(parents=True, exist_ok=True)
    fname = sanitize_filename(title)
    path = ensure_unique_path(folder, fname)
    doc = Document()
    doc.add_heading(title, 0)
    for para in content.split("\n"):
        doc.add_paragraph(para)
    doc.save(path)
    return path

def main():
    cfg = load_config()
    sn = cfg["servicenow"]
    instance_url = sn.get("instance_url")
    login_mode = sn.get("login_mode", "sso").lower()
    username = sn.get("username", "")
    password = sn.get("password", "")
    browser = sn.get("browser", "chrome")
    headless = sn.getboolean("headless", False)
    wait_timeout = sn.getint("wait_timeout", 25)
    excel_path = sn.get("urls_excel", "urls.xlsx")
    sheet = sn.get("excel_sheet", None)
    url_col = sn.get("url_column", None)
    output_folder = Path(sn.get("output_folder", "output"))
    delay_seconds = sn.getfloat("delay_seconds", 1.0)

    urls = read_urls_from_excel(excel_path, sheet, url_col)
    driver = create_driver(browser, headless)

    try:
        if login_mode == "basic":
            login_basic(driver, instance_url, username, password, wait_timeout)
        else:
            ensure_logged_in_sso(driver, urls[0], wait_timeout)

        for idx, url in enumerate(urls, start=1):
            logger.info(f"[{idx}/{len(urls)}] Processing: {url}")
            driver.get(url)
            switched = switch_into_frame(driver)
            WebDriverWait(driver, wait_timeout).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "h1#articleTitleReadonly"))
            )
            html = driver.page_source
            if switched:
                driver.switch_to.default_content()
            title, content = extract_title_and_content(html)
            saved_path = save_to_word(output_folder, title, content)
            logger.info(f"Saved: {saved_path.name}")
            time.sleep(delay_seconds)
    finally:
        driver.quit()
        logger.info("Done.")

if __name__ == "__main__":
    main()
